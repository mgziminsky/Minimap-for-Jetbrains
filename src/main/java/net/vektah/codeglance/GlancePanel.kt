/*
 * Copyright Â© 2013, Adam Scarr
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package net.vektah.codeglance

import com.intellij.openapi.Disposable
import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.components.ServiceManager
import com.intellij.openapi.editor.FoldRegion
import com.intellij.openapi.editor.colors.ColorKey
import com.intellij.openapi.editor.event.DocumentAdapter
import com.intellij.openapi.editor.event.DocumentEvent
import com.intellij.openapi.editor.event.DocumentListener
import com.intellij.openapi.editor.event.SelectionListener
import com.intellij.openapi.editor.event.VisibleAreaListener
import com.intellij.openapi.editor.ex.EditorEx
import com.intellij.openapi.editor.ex.FoldingListener
import com.intellij.openapi.fileEditor.TextEditor
import com.intellij.openapi.progress.ProgressIndicator
import com.intellij.openapi.progress.util.ProgressIndicatorUtils
import com.intellij.openapi.progress.util.ReadTask
import com.intellij.openapi.project.Project
import com.intellij.openapi.util.Disposer
import com.intellij.openapi.vfs.PersistentFSConstants
import com.intellij.ui.JBColor
import com.intellij.util.ui.UIUtil
import net.vektah.codeglance.concurrent.DirtyLock
import net.vektah.codeglance.config.Config
import net.vektah.codeglance.config.ConfigService
import net.vektah.codeglance.render.Minimap
import net.vektah.codeglance.render.ScrollState
import java.awt.AlphaComposite
import java.awt.BorderLayout
import java.awt.Dimension
import java.awt.Graphics
import java.awt.Graphics2D
import java.awt.event.ComponentAdapter
import java.awt.event.ComponentEvent
import java.awt.event.ComponentListener
import java.awt.event.HierarchyEvent
import java.awt.image.BufferedImage
import java.lang.ref.SoftReference
import javax.swing.JPanel

/**
 * This JPanel gets injected into editor windows and renders a image generated by GlanceFileRenderer
 */
class GlancePanel(private val project: Project, textEditor: TextEditor) : JPanel(), Disposable {
    private val editor = textEditor.editor as EditorEx
    private var mapRef = SoftReference<Minimap>(null)
    private val configService = ServiceManager.getService(ConfigService::class.java)
    private var config: Config = configService.state!!
    private var buf: BufferedImage? = null
    private val renderLock = DirtyLock()
    private val scrollstate = ScrollState()
    private val scrollbar = Scrollbar(editor, scrollstate)

    // Anonymous Listeners that should be cleaned up.
    private val componentListener: ComponentListener
    private val documentListener: DocumentListener
    private val areaListener: VisibleAreaListener
    private val selectionListener: SelectionListener = SelectionListener { repaint() }

    private val updateTask: ReadTask

    private val isDisabled: Boolean
        get() = config.disabled || editor.document.textLength > PersistentFSConstants.getMaxIntellisenseFileSize() || editor.document.lineCount < config.minLineCount || parent == null || parent.width < config.minWindowWidth

    init {
        Disposer.register(textEditor, this)
        Disposer.register(this, scrollbar)

        this.addHierarchyListener {
            if (it.changeFlags.and(HierarchyEvent.PARENT_CHANGED.toLong()) != 0L) {
                refresh()
            }
        }

        configService.addOnChange(this::refresh)

        componentListener = object : ComponentAdapter() {
            override fun componentResized(componentEvent: ComponentEvent?) = updateImage()
        }
        editor.contentComponent.addComponentListener(componentListener)

        documentListener = object : DocumentAdapter() {
            override fun documentChanged(documentEvent: DocumentEvent?) = updateImage()
        }
        editor.document.addDocumentListener(documentListener)

        val foldListener = object : FoldingListener{
            override fun onFoldProcessingEnd() = updateImage()

            override fun onFoldRegionStateChange(region: FoldRegion) = updateImage()
        }
        editor.foldingModel.addListener(foldListener, this)

        areaListener = VisibleAreaListener{
            scrollstate.recomputeVisible(it.newRectangle)
            repaint()
        }
        editor.scrollingModel.addVisibleAreaListener(areaListener)

        editor.selectionModel.addSelectionListener(selectionListener)

        updateTask = object : ReadTask {
            override fun onCanceled(indicator: ProgressIndicator) = updateImage()

            override fun computeInReadAction(indicator: ProgressIndicator) {
                val map = getOrCreateMap() ?: return

                try {
                    scrollstate.computeDimensions(editor, config)
                    map.update(editor, scrollstate, indicator)
                    ApplicationManager.getApplication().invokeLater {
                        scrollstate.recomputeVisible(editor.scrollingModel.visibleArea)
                        repaint()
                    }
                }
                finally {
                    renderLock.release()
                    if (renderLock.dirty) {
                        renderLock.clean()
                        updateImageSoon()
                    }
                }
            }
        }

        isOpaque = false
        layout = BorderLayout()
        add(scrollbar)

        refresh()
    }

    private fun refresh() {
        updateImage()
        updateSize()
        parent?.revalidate()
    }

    /**
     * Adjusts the panels size to be a percentage of the total window
     */
    private fun updateSize() {
        preferredSize = if (isDisabled) {
            Dimension(0, 0)
        } else {
            Dimension(config.width, 0)
        }
    }

    // the minimap is held by a soft reference so the GC can delete it at any time.
    // if its been deleted and we want it again (active tab) we recreate it.
    private fun getOrCreateMap() : Minimap? {
        var map = mapRef.get()

        if (map == null) {
            map = Minimap(configService.state!!)
            mapRef = SoftReference(map)
        }

        return map
    }

    /**
     * Fires off a new task to the worker thread. This should only be called from the ui thread.
     */
    private fun updateImage() {
        if (isDisabled) return
        if (project.isDisposed) return
        if (!renderLock.acquire()) return

        ProgressIndicatorUtils.scheduleWithWriteActionPriority(updateTask)
    }

    private fun updateImageSoon() = ApplicationManager.getApplication().invokeLater(this::updateImage)

    private fun paintLast(gfx: Graphics?) {
        val g = gfx as Graphics2D

        if (buf != null) {
            g.drawImage(buf,
                0, 0, buf!!.width, buf!!.height,
                0, 0, buf!!.width, buf!!.height,
                null)
        }
        paintSelections(g)
        scrollbar.paint(gfx)
    }

    private fun paintSelection(g: Graphics2D, startByte: Int, endByte: Int) {
        val start = editor.offsetToVisualPosition(startByte)
        val end = editor.offsetToVisualPosition(endByte)

        val sX = start.column
        val sY = start.line * config.pixelsPerLine - scrollstate.visibleStart
        val eX = end.column + 1
        val eY = end.line * config.pixelsPerLine - scrollstate.visibleStart

        g.composite = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.80f)
        g.color = editor.colorsScheme.getColor(ColorKey.createColorKey("SELECTION_BACKGROUND", JBColor.BLUE))

        // Single line is real easy
        if (start.line == end.line) {
            g.fillRect(
                sX,
                sY,
                eX - sX,
                config.pixelsPerLine
            )
        } else {
            // Draw the line leading in
            g.fillRect(sX, sY, width - sX, config.pixelsPerLine)

            // Then the line at the end
            g.fillRect(0, eY, eX, config.pixelsPerLine)

            if (eY + config.pixelsPerLine != sY) {
                // And if there is anything in between, fill it in
                g.fillRect(0, sY + config.pixelsPerLine, width, eY - sY - config.pixelsPerLine)
            }
        }
    }

    private fun paintSelections(g: Graphics2D) {
        for ((index, start) in editor.selectionModel.blockSelectionStarts.withIndex()) {
            paintSelection(g, start, editor.selectionModel.blockSelectionEnds[index])
        }
    }

    override fun paint(gfx: Graphics?) {
        if (renderLock.locked) {
            paintLast(gfx)
            return
        }

        val minimap = mapRef.get()
        if (minimap == null) {
            updateImageSoon()
            paintLast(gfx)
            return
        }

        if (buf == null || buf?.width!! < width || buf?.height!! < height) {
            buf = UIUtil.createImage(width, height, BufferedImage.TYPE_4BYTE_ABGR)
        }

        val g = buf!!.createGraphics()

        g.composite = AlphaComposite.getInstance(AlphaComposite.CLEAR)
        g.fillRect(0, 0, width, height)
        g.composite = AlphaComposite.getInstance(AlphaComposite.SRC_OVER)

        if (editor.document.textLength != 0) {
            g.drawImage(
                minimap.img,
                0, 0, scrollstate.documentWidth, scrollstate.drawHeight,
                0, scrollstate.visibleStart, scrollstate.documentWidth, scrollstate.visibleEnd,
                null
            )
        }

        paintSelections(gfx as Graphics2D)
        gfx.drawImage(buf, 0, 0, null)
        scrollbar.paint(gfx)
    }

    override fun dispose() {
        configService.removeOnChange(this::refresh)
        editor.contentComponent.removeComponentListener(componentListener)
        editor.document.removeDocumentListener(documentListener)
        editor.scrollingModel.removeVisibleAreaListener(areaListener)
        editor.selectionModel.removeSelectionListener(selectionListener)
        remove(scrollbar)

        mapRef.clear()
    }
}
